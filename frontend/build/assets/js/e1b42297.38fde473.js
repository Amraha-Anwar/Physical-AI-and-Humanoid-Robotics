"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[715],{151:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(8168),a=(n(6540),n(5680));const i={sidebar_position:1,title:"ROS 2 Architecture & Core Concepts"},o="ROS 2 Architecture & Core Concepts",l={unversionedId:"module1/architecture-concepts",id:"module1/architecture-concepts",title:"ROS 2 Architecture & Core Concepts",description:"Learning Objectives",source:"@site/docs/module1/01-architecture-concepts.mdx",sourceDirName:"module1",slug:"/module1/architecture-concepts",permalink:"/docs/module1/architecture-concepts",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module1/01-architecture-concepts.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"ROS 2 Architecture & Core Concepts"},sidebar:"tutorialSidebar",previous:{title:"Setup Guide - Physical AI Edge Kit",permalink:"/docs/intro/setup-edge-kit"},next:{title:"Packages and rclpy",permalink:"/docs/module1/packages-rclpy"}},s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to ROS 2",id:"introduction-to-ros-2",level:2},{value:"Core Communication Patterns",id:"core-communication-patterns",level:2},{value:"1. Nodes",id:"1-nodes",level:3},{value:"2. Topics",id:"2-topics",level:3},{value:"3. Services",id:"3-services",level:3},{value:"4. Actions",id:"4-actions",level:3},{value:"ROS 2 Architecture Sketch (Diagram Tag)",id:"ros-2-architecture-sketch-diagram-tag",level:2},{value:"The Role of Data Distribution Service (DDS)",id:"the-role-of-data-distribution-service-dds",level:2},{value:"Key benefits of DDS in ROS 2:",id:"key-benefits-of-dds-in-ros-2",level:3},{value:"ROS 1 vs. ROS 2: A Comparison",id:"ros-1-vs-ros-2-a-comparison",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c},d="wrapper";function g({components:e,...t}){return(0,a.yg)(d,(0,r.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"ros-2-architecture--core-concepts"},"ROS 2 Architecture & Core Concepts"),(0,a.yg)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,a.yg)("p",null,"Upon completing this chapter, you will be able to:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Understand the fundamental building blocks of ROS 2."),(0,a.yg)("li",{parentName:"ul"},"Differentiate between the four core communication patterns in ROS 2 (Nodes, Topics, Services, Actions)."),(0,a.yg)("li",{parentName:"ul"},"Explain the role of Data Distribution Service (DDS) in ROS 2's distributed architecture."),(0,a.yg)("li",{parentName:"ul"},"Compare and contrast the architectural philosophies of ROS 1 and ROS 2.")),(0,a.yg)("h2",{id:"introduction-to-ros-2"},"Introduction to ROS 2"),(0,a.yg)("p",null,"The Robot Operating System (ROS) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behaviors across a wide variety of robotic platforms. ROS 2 is the latest iteration, re-engineered to address the limitations of ROS 1, particularly concerning real-time performance, multi-robot systems, and embedded hardware integration."),(0,a.yg)("p",null,"Unlike its predecessor, ROS 2 is built on a ",(0,a.yg)("strong",{parentName:"p"},"distributed, decentralized architecture")," leveraging the Data Distribution Service (DDS) standard. This change is fundamental, moving away from ROS 1's centralized master node to a peer-to-peer communication model, which inherently offers better scalability, reliability, and real-time capabilities."),(0,a.yg)("h2",{id:"core-communication-patterns"},"Core Communication Patterns"),(0,a.yg)("p",null,"ROS 2 organizes robot applications into a graph of ",(0,a.yg)("strong",{parentName:"p"},"nodes"),", which communicate with each other using well-defined communication patterns."),(0,a.yg)("h3",{id:"1-nodes"},"1. Nodes"),(0,a.yg)("p",null,"A ",(0,a.yg)("strong",{parentName:"p"},"Node")," is an executable process that performs computation. Nodes are typically designed to do one thing well, following the Unix philosophy. For example, one node might control a motor, another might process camera data, and yet another might implement a navigation algorithm."),(0,a.yg)("p",null,"Nodes can be written in various programming languages (Python, C++) and execute independently. Communication between nodes is handled by the underlying ROS 2 middleware (DDS)."),(0,a.yg)("h3",{id:"2-topics"},"2. Topics"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Topics")," are the primary mechanism for asynchronous, many-to-many, publish-subscribe communication in ROS 2."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Publisher"),": A node that sends messages to a topic."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Subscriber"),": A node that receives messages from a topic.")),(0,a.yg)("p",null,"When a node publishes data to a topic, any node subscribed to that topic will receive the data. This pattern is ideal for streaming data like sensor readings (e.g., camera images, LiDAR scans), odometry, or joint states."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Key characteristics:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Asynchronous"),": Publishers don't wait for subscribers to receive messages."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Many-to-many"),": Multiple publishers can send to the same topic, and multiple subscribers can listen to the same topic."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Message Types"),": Each topic has a defined message type (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"sensor_msgs/msg/Image"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"geometry_msgs/msg/Twist"),").")),(0,a.yg)("h3",{id:"3-services"},"3. Services"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Services")," provide a synchronous, request-reply communication model. They are used for operations that involve a request for computation and a response with the result."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Service Client"),": A node that sends a request and waits for a response."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Service Server"),": A node that receives a request, performs a computation, and sends back a response.")),(0,a.yg)("p",null,'This pattern is suitable for discrete tasks that require immediate feedback, such as triggering a robot to perform a specific action (e.g., "turn on a light," "get the current map," "solve an inverse kinematics problem").'),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Key characteristics:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Synchronous"),": The client blocks until it receives a response or times out."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"One-to-one"),": A single request from a client receives a single response from a server."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Service Types"),": Each service has a defined request and response structure.")),(0,a.yg)("h3",{id:"4-actions"},"4. Actions"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Actions")," are a high-level communication pattern designed for long-running, goal-oriented tasks that provide periodic feedback and can be preempted. They combine aspects of both Topics and Services."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Action Client"),": Sends a goal, can receive continuous feedback, and eventually a result. Can also send a cancellation request."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Action Server"),": Receives a goal, executes the task, sends periodic feedback, and finally a result. Can handle cancellation requests.")),(0,a.yg)("p",null,'Actions are perfect for tasks like "navigate to a specific location," "pick up an object," or "perform a complex manipulation sequence," where progress updates are valuable, and the task might need to be interrupted.'),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Key characteristics:")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Asynchronous (Client perspective)"),": Client doesn't block entirely, receives feedback."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Goal-oriented"),": Defined by a goal, feedback, and result."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Preemptable"),": Clients can cancel a running action.")),(0,a.yg)("h2",{id:"ros-2-architecture-sketch-diagram-tag"},"ROS 2 Architecture Sketch (Diagram Tag)"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-mermaid"},'graph TD\n    subgraph "ROS 2 System (DDS Middleware)"\n        A[Node A] -- Publish/Subscribe (Topic) --\x3e B[Node B]\n        A -- Call/Reply (Service) --\x3e C[Node C]\n        A -- Send Goal/Get Feedback/Get Result (Action) --\x3e D[Node D]\n        B -- Publish/Subscribe (Topic) --\x3e E[Node E]\n        D -- Action Server (Feedback/Result) --\x3e D\n    end\n\n    subgraph "Hardware Abstraction"\n        E -- Control Commands --\x3e F[Robot Hardware]\n        F -- Sensor Data --\x3e E\n    end\n\n    subgraph "Tooling"\n        G[Rviz2] -- Subscribe to Topics --\x3e B, E\n        H[rqt_graph] -- Introspect Graph --\x3e B, C, D, E\n    end\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#bfb,stroke:#333,stroke-width:2px\n    style D fill:#fdd,stroke:#333,stroke-width:2px\n    style E fill:#dbf,stroke:#333,stroke-width:2px\n    style F fill:#ccc,stroke:#333,stroke-width:2px\n    style G fill:#fff,stroke:#333,stroke-width:2px\n    style H fill:#fff,stroke:#333,stroke-width:2px\n\n    linkStyle 0 stroke:#00a,stroke-width:1.5px,fill:none;\n    linkStyle 1 stroke:#0a0,stroke-width:1.5px,fill:none;\n    linkStyle 2 stroke:#a00,stroke-width:1.5px,fill:none;\n    linkStyle 3 stroke:#00a,stroke-width:1.5px,fill:none;\n    linkStyle 4 stroke:#a0a,stroke-width:1.5px,fill:none;\n    linkStyle 5 stroke:#000,stroke-width:1.5px,fill:none;\n    linkStyle 6 stroke:#000,stroke-width:1.5px,fill:none;\n    linkStyle 7 stroke:#555,stroke-width:1.5px,fill:none;\n    linkStyle 8 stroke:#555,stroke-width:1.5px,fill:none;\n')),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"Figure 1: Simplified ROS 2 System Architecture illustrating core communication patterns.")),(0,a.yg)("h2",{id:"the-role-of-data-distribution-service-dds"},"The Role of Data Distribution Service (DDS)"),(0,a.yg)("p",null,"A cornerstone of ROS 2's design is its reliance on the ",(0,a.yg)("strong",{parentName:"p"},"Data Distribution Service (DDS)")," standard for all inter-process communication. DDS is an open international standard for publish-subscribe communication for real-time and embedded systems."),(0,a.yg)("h3",{id:"key-benefits-of-dds-in-ros-2"},"Key benefits of DDS in ROS 2:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Decentralization"),": Unlike ROS 1's ",(0,a.yg)("inlineCode",{parentName:"li"},"roscore")," (a central master node), DDS enables direct peer-to-peer communication between nodes. This eliminates single points of failure, improves fault tolerance, and simplifies multi-robot deployments."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Quality of Service (QoS)"),": DDS provides a rich set of QoS policies that allow developers to fine-tune communication behavior. This includes:",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Reliability"),": Guaranteed delivery vs. best-effort."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Durability"),": Whether late-joining subscribers receive historical data."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Liveliness"),": Detection of whether publishers are still active."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"History"),": How much data to keep for late joiners or transient local storage.\nThese policies are critical for real-time and safety-critical applications."))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Pluggable Middleware"),': ROS 2 abstracts the DDS implementation, allowing different DDS vendors (e.g., Fast RTPS, Cyclone DDS, RTI Connext) to be "plugged in" without changing ROS 2 application code. This provides flexibility and performance optimization options.'),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Multi-robot & Network Support"),": DDS is inherently designed for distributed systems, making ROS 2 suitable for complex multi-robot scenarios and communication across various network topologies.")),(0,a.yg)("h2",{id:"ros-1-vs-ros-2-a-comparison"},"ROS 1 vs. ROS 2: A Comparison"),(0,a.yg)("p",null,"Understanding the architectural shift from ROS 1 to ROS 2 is crucial for developers transitioning between the two versions."),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:"left"},"Feature"),(0,a.yg)("th",{parentName:"tr",align:"left"},"ROS 1"),(0,a.yg)("th",{parentName:"tr",align:"left"},"ROS 2"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Architecture")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Centralized (",(0,a.yg)("inlineCode",{parentName:"td"},"roscore")," master node)"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Decentralized (DDS, peer-to-peer)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Communication")),(0,a.yg)("td",{parentName:"tr",align:"left"},"TCP/IP (Topics, Services), XML-RPC"),(0,a.yg)("td",{parentName:"tr",align:"left"},"DDS (Topics, Services, Actions)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Real-time")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Limited (best-effort)"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Improved (DDS QoS, real-time executors)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Multi-robot")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Challenging, often custom solutions"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Built-in (DDS discovery, network isolation)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Embedded Systems")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Resource-intensive"),(0,a.yg)("td",{parentName:"tr",align:"left"},"More suitable (smaller footprint, efficient DDS)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Quality of Service")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Basic, mostly implicit"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Explicit and configurable via DDS QoS policies")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Security")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Lacks built-in security"),(0,a.yg)("td",{parentName:"tr",align:"left"},"DDS-Security (Authentication, Encryption)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Language Support")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Python 2/3, C++"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Python 3, C++, Java, C#, etc. (more robust APIs)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Windows/macOS")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Primarily Linux"),(0,a.yg)("td",{parentName:"tr",align:"left"},"First-class support for Windows, macOS, Linux")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:"left"},(0,a.yg)("strong",{parentName:"td"},"Long-running Tasks")),(0,a.yg)("td",{parentName:"tr",align:"left"},"Services with external state/feedback"),(0,a.yg)("td",{parentName:"tr",align:"left"},"Dedicated Action interface")))),(0,a.yg)("p",null,"The shift to DDS and a decentralized architecture fundamentally improves ROS 2's capabilities in areas critical for modern robotics, such as real-time performance, scalability, and security."),(0,a.yg)("h2",{id:"conclusion"},"Conclusion"),(0,a.yg)("p",null,"ROS 2 provides a robust and flexible framework for developing advanced robotic applications. Its decentralized architecture, built upon the DDS standard, and its comprehensive set of communication patterns (Nodes, Topics, Services, Actions) empower developers to create highly capable and distributed robot software. The improvements over ROS 1 make it a powerful choice for contemporary Physical AI and humanoid robotics projects."),(0,a.yg)("hr",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Next Steps"),": In the next chapter, we will delve into practical aspects of writing ROS 2 nodes, focusing on Python (",(0,a.yg)("inlineCode",{parentName:"p"},"rclpy"),"), and explore how to create your first ROS 2 packages."))}g.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>u});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){a(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef(function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,u=d["".concat(s,".").concat(m)]||d[m]||g[m]||i;return n?r.createElement(u,o(o({ref:t},p),{},{components:n})):r.createElement(u,o({ref:t},p))});function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);