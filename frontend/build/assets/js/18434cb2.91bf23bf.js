"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[488],{3384:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>s,contentTitle:()=>r,default:()=>y,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=n(8168),o=(n(6540),n(5680));const a={sidebar_position:2,title:"Physics and Collision Simulation"},r="Physics and Collision Simulation",l={unversionedId:"module2/physics-collision",id:"module2/physics-collision",title:"Physics and Collision Simulation",description:"Learning Objectives",source:"@site/docs/module2/02-physics-collision.mdx",sourceDirName:"module2",slug:"/module2/physics-collision",permalink:"/docs/module2/physics-collision",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module2/02-physics-collision.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Physics and Collision Simulation"},sidebar:"tutorialSidebar",previous:{title:"Gazebo Simulation Setup",permalink:"/docs/module2/gazebo-setup"},next:{title:"Sensor Simulation",permalink:"/docs/module2/sensor-simulation"}},s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Realistic Physics Simulation",id:"introduction-to-realistic-physics-simulation",level:2},{value:"1. Configuring Rigid Body Dynamics",id:"1-configuring-rigid-body-dynamics",level:2},{value:"Example: Inertial Properties for a Cylinder",id:"example-inertial-properties-for-a-cylinder",level:3},{value:"2. Gravity and Contact Properties",id:"2-gravity-and-contact-properties",level:2},{value:"Gravity",id:"gravity",level:3},{value:"Contact Properties and Friction",id:"contact-properties-and-friction",level:3},{value:"Physics Engine Parameters",id:"physics-engine-parameters",level:3},{value:"3. Implementing Collision Geometries",id:"3-implementing-collision-geometries",level:2},{value:"Troubleshooting Physics and Collision",id:"troubleshooting-physics-and-collision",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c},m="wrapper";function y({components:e,...i}){return(0,o.yg)(m,(0,t.A)({},p,i,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"physics-and-collision-simulation"},"Physics and Collision Simulation"),(0,o.yg)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,o.yg)("p",null,"Upon completing this chapter, you will be able to:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Understand the importance of realistic physics simulation for humanoid robotics."),(0,o.yg)("li",{parentName:"ul"},"Configure rigid body dynamics (mass, inertia) in your robot's URDF/SDF."),(0,o.yg)("li",{parentName:"ul"},"Define gravity and contact properties within a Gazebo world."),(0,o.yg)("li",{parentName:"ul"},"Implement collision geometries for accurate physical interactions."),(0,o.yg)("li",{parentName:"ul"},"Troubleshoot common physics and collision issues in Gazebo.")),(0,o.yg)("h2",{id:"introduction-to-realistic-physics-simulation"},"Introduction to Realistic Physics Simulation"),(0,o.yg)("p",null,"For humanoid robots, realistic physical simulation is paramount. Accurate physics allow us to:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Test balance and gait"),": Crucial for bipedal locomotion."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Simulate interactions"),": With objects in the environment."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Evaluate robustness"),": Of control algorithms under various conditions."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Generate synthetic data"),": For machine learning models.")),(0,o.yg)("p",null,"Gazebo's physics engine provides these capabilities, but it requires careful configuration of your robot model and the simulation environment."),(0,o.yg)("h2",{id:"1-configuring-rigid-body-dynamics"},"1. Configuring Rigid Body Dynamics"),(0,o.yg)("p",null,"The core of realistic physics lies in correctly defining the properties of each ",(0,o.yg)("inlineCode",{parentName:"p"},"link")," in your robot's URDF/SDF. These properties are defined within the ",(0,o.yg)("inlineCode",{parentName:"p"},"<inertial>")," tag of each link."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Mass"),": The total mass of the link (in kg)."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Inertia Matrix"),": A 3x3 matrix (",(0,o.yg)("inlineCode",{parentName:"li"},"ixx"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"ixy"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"ixz"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"iyy"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"iyz"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"izz"),") that describes how difficult it is to rotate the link about its center of mass. This is often the most challenging part to get right without CAD tools."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Origin"),": The center of mass of the link relative to the link's own frame.")),(0,o.yg)("p",null,"Let's enhance our ",(0,o.yg)("inlineCode",{parentName:"p"},"torso_link")," from ",(0,o.yg)("inlineCode",{parentName:"p"},"humanoid_segment.urdf.xacro")," with more realistic inertial properties. For a cylinder, these can be calculated or approximated."),(0,o.yg)("h3",{id:"example-inertial-properties-for-a-cylinder"},"Example: Inertial Properties for a Cylinder"),(0,o.yg)("p",null,"For a cylinder with mass ",(0,o.yg)("inlineCode",{parentName:"p"},"m"),", radius ",(0,o.yg)("inlineCode",{parentName:"p"},"r"),", and length ",(0,o.yg)("inlineCode",{parentName:"p"},"l"),", aligned with the Z-axis, the inertia matrix is:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"ixx = iyy = m * (3*r^2 + l^2) / 12")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"izz = m * r^2 / 2")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"ixy = ixz = iyz = 0"))),(0,o.yg)("p",null,"We'll use estimated values for simplicity:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-xml"},'  \x3c!-- BASE LINK: Torso --\x3e\n  <link name="torso_link">\n    \x3c!-- ... visual and collision tags remain ... --\x3e\n    <inertial>\n      <origin xyz="0 0 0" rpy="0 0 0"/> \x3c!-- Center of mass at link origin --\x3e\n      <mass value="5.0"/> \x3c!-- 5 kg --\x3e\n      <inertia ixx="0.04" ixy="0.0" ixz="0.0" iyy="0.04" iyz="0.0" izz="0.005"/>\n    </inertial>\n  </link>\n')),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Key Takeaway"),": Incorrect ",(0,o.yg)("inlineCode",{parentName:"p"},"mass")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"inertia")," values will lead to unrealistic robot behavior (e.g., floating, excessive wobbling, or inability to balance). Start with reasonable estimates and refine if necessary."),(0,o.yg)("h2",{id:"2-gravity-and-contact-properties"},"2. Gravity and Contact Properties"),(0,o.yg)("h3",{id:"gravity"},"Gravity"),(0,o.yg)("p",null,"Gravity is a fundamental force in any physical simulation. In Gazebo, it's typically defined at the world level within the SDF file. Our ",(0,o.yg)("inlineCode",{parentName:"p"},"empty_humanoid_world.world")," already includes gravity by default. You can explicitly set it:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-xml"},"        <gravity>0 0 -9.8</gravity> \x3c!-- Standard gravity along Z-axis --\x3e\n")),(0,o.yg)("p",null,"This line is often implicit if using a standard ",(0,o.yg)("inlineCode",{parentName:"p"},"physics")," block, but it's good to be aware of."),(0,o.yg)("h3",{id:"contact-properties-and-friction"},"Contact Properties and Friction"),(0,o.yg)("p",null,"For bipedal locomotion, the interaction between the robot's feet and the ground is critical. This is governed by contact properties, mainly friction. These are defined within the ",(0,o.yg)("inlineCode",{parentName:"p"},"<collision>")," element's ",(0,o.yg)("inlineCode",{parentName:"p"},"<surface>")," tag."),(0,o.yg)("p",null,"In our ",(0,o.yg)("inlineCode",{parentName:"p"},"empty_humanoid_world.world"),", the ",(0,o.yg)("inlineCode",{parentName:"p"},"ground_plane")," has friction properties:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-xml"},"            <surface>\n                <friction>\n                  <ode>\n                    <mu>100</mu>    \x3c!-- Coefficient of static friction --\x3e\n                    <mu2>50</mu2>   \x3c!-- Coefficient of dynamic friction --\x3e\n                  </ode>\n                </friction>\n            </surface>\n")),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"mu"),": Coefficient of static friction."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"mu2"),": Coefficient of dynamic friction.")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"For your robot's links"),", you also need to define friction, especially for parts that will make contact with the environment (e.g., feet, end-effectors). You can add a similar ",(0,o.yg)("inlineCode",{parentName:"p"},"<surface>")," tag inside the ",(0,o.yg)("inlineCode",{parentName:"p"},"<collision>")," of your links if they need to interact with friction."),(0,o.yg)("h3",{id:"physics-engine-parameters"},"Physics Engine Parameters"),(0,o.yg)("p",null,"Gazebo allows you to choose and configure different physics engines (ODE, Bullet, DART, Simbody). The ",(0,o.yg)("inlineCode",{parentName:"p"},"<physics>")," block in the world file controls global simulation parameters:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-xml"},'        <physics name="1ms" type="ode"> \x3c!-- Using ODE physics engine --\x3e\n          <max_step_size>0.001</max_step_size> \x3c!-- Simulation step size (1ms) --\x3e\n          <real_time_factor>1.0</real_time_factor> \x3c!-- Run simulation at real-time speed --\x3e\n        </physics>\n')),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"max_step_size"),": Controls the precision of the physics simulation. Smaller values are more accurate but computationally more expensive."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"real_time_factor"),": The ratio of simulated time to real time. A value of 1.0 means the simulation attempts to run at real-time speed.")),(0,o.yg)("h2",{id:"3-implementing-collision-geometries"},"3. Implementing Collision Geometries"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"<collision>")," element within a URDF ",(0,o.yg)("inlineCode",{parentName:"p"},"link")," defines the robot's physical shape for collision detection. This geometry is often simpler than the ",(0,o.yg)("inlineCode",{parentName:"p"},"<visual>")," geometry to reduce computational load during collision checks."),(0,o.yg)("p",null,"Gazebo primarily uses the collision geometry to calculate contacts and apply forces."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-xml"},'  \x3c!-- BASE LINK: Torso --\x3e\n  <link name="torso_link">\n    \x3c!-- ... visual tag ... --\x3e\n    <collision name="torso_collision"> \x3c!-- Give collision a unique name --\x3e\n      <geometry>\n        <cylinder length="${torso_length}" radius="${torso_radius}"/>\n      </geometry>\n      \x3c!-- Optional: Add origin if collision geometry is offset from link origin --\x3e\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      \x3c!-- Optional: Add surface properties if this link will make contact --\x3e\n      <surface>\n        <friction>\n          <ode>\n            <mu>0.9</mu>\n            <mu2>0.8</mu2>\n          </ode>\n        </friction>\n      </surface>\n    </collision>\n    \x3c!-- ... inertial tag ... --\x3e\n  </link>\n')),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Important"),":"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Collision shapes should fully enclose the visual shapes.")," If not, parts of your robot might pass through objects in the simulation."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Prefer simple collision shapes")," (boxes, spheres, cylinders) for performance. Use ",(0,o.yg)("inlineCode",{parentName:"li"},"<mesh>")," for complex shapes only if necessary."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Always define collision geometry"),", even for visually insignificant parts, if they might physically interact with the environment or other robot parts.")),(0,o.yg)("h2",{id:"troubleshooting-physics-and-collision"},"Troubleshooting Physics and Collision"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Robot floating or sinking"),": Incorrect mass or inertia values."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Robot shaking or unstable"),": Physics engine parameters (",(0,o.yg)("inlineCode",{parentName:"li"},"max_step_size"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"friction"),"), or unstable joints. Try reducing ",(0,o.yg)("inlineCode",{parentName:"li"},"max_step_size"),"."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Robot falling through ground"),": Missing collision geometry for the ground or robot parts, or incorrect ",(0,o.yg)("inlineCode",{parentName:"li"},"origin")," for collision."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},'Unrealistic "bounciness"'),": Adjust restitution properties (",(0,o.yg)("inlineCode",{parentName:"li"},"bounce"),") in the ",(0,o.yg)("inlineCode",{parentName:"li"},"<surface>")," tag."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Excessive sliding"),": Adjust friction coefficients (",(0,o.yg)("inlineCode",{parentName:"li"},"mu"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"mu2"),").")),(0,o.yg)("h2",{id:"conclusion"},"Conclusion"),(0,o.yg)("p",null,"By carefully defining rigid body dynamics, gravity, and accurate collision geometries, you can create a physically realistic simulation of your humanoid robot in Gazebo. This detailed attention to physics enables more meaningful development and testing of locomotion and interaction algorithms."),(0,o.yg)("hr",null),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Next Steps"),": With robust physics in place, the next crucial step is to integrate various simulated sensors into our Gazebo environment, allowing our robot to perceive its surroundings and publish that data to ROS 2."))}y.isMDXComponent=!0},5680:(e,i,n)=>{n.d(i,{xA:()=>p,yg:()=>g});var t=n(6540);function o(e,i,n){return i in e?Object.defineProperty(e,i,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[i]=n,e}function a(e,i){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);i&&(t=t.filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable})),n.push.apply(n,t)}return n}function r(e){for(var i=1;i<arguments.length;i++){var n=null!=arguments[i]?arguments[i]:{};i%2?a(Object(n),!0).forEach(function(i){o(e,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))})}return e}function l(e,i){if(null==e)return{};var n,t,o=function(e,i){if(null==e)return{};var n,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)n=a[t],i.indexOf(n)>=0||(o[n]=e[n]);return o}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)n=a[t],i.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=t.createContext({}),c=function(e){var i=t.useContext(s),n=i;return e&&(n="function"==typeof e?e(i):r(r({},i),e)),n},p=function(e){var i=c(e.components);return t.createElement(s.Provider,{value:i},e.children)},m="mdxType",y={inlineCode:"code",wrapper:function(e){var i=e.children;return t.createElement(t.Fragment,{},i)}},u=t.forwardRef(function(e,i){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=o,g=m["".concat(s,".").concat(u)]||m[u]||y[u]||a;return n?t.createElement(g,r(r({ref:i},p),{},{components:n})):t.createElement(g,r({ref:i},p))});function g(e,i){var n=arguments,o=i&&i.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=u;var l={};for(var s in i)hasOwnProperty.call(i,s)&&(l[s]=i[s]);l.originalType=e,l[m]="string"==typeof e?e:o,r[1]=l;for(var c=2;c<a;c++)r[c]=n[c];return t.createElement.apply(null,r)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);