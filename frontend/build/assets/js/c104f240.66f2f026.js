"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[663],{4881:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var t=a(8168),o=(a(6540),a(5680));const i={sidebar_position:1,title:"Gazebo Simulation Setup"},r="Gazebo Simulation Setup",l={unversionedId:"module2/gazebo-setup",id:"module2/gazebo-setup",title:"Gazebo Simulation Setup",description:"Learning Objectives",source:"@site/docs/module2/01-gazebo-setup.mdx",sourceDirName:"module2",slug:"/module2/gazebo-setup",permalink:"/docs/module2/gazebo-setup",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module2/01-gazebo-setup.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Gazebo Simulation Setup"},sidebar:"tutorialSidebar",previous:{title:"Robot Modeling (URDF)",permalink:"/docs/module1/urdf-rviz2"},next:{title:"Physics and Collision Simulation",permalink:"/docs/module2/physics-collision"}},s={},p=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Gazebo (Ignition)",id:"introduction-to-gazebo-ignition",level:2},{value:"1. Installing Gazebo (Ignition)",id:"1-installing-gazebo-ignition",level:2},{value:"2. Creating a Basic Gazebo World",id:"2-creating-a-basic-gazebo-world",level:2},{value:"3. Integrating URDF Models into Gazebo",id:"3-integrating-urdf-models-into-gazebo",level:2},{value:"URDF vs. SDF: Complementary Roles",id:"urdf-vs-sdf-complementary-roles",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p},d="wrapper";function g({components:e,...n}){return(0,o.yg)(d,(0,t.A)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"gazebo-simulation-setup"},"Gazebo Simulation Setup"),(0,o.yg)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,o.yg)("p",null,"Upon completing this chapter, you will be able to:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Understand the role of Gazebo (Ignition) as a robot simulator in the ROS 2 ecosystem."),(0,o.yg)("li",{parentName:"ul"},"Install and configure Gazebo (Ignition) on your system."),(0,o.yg)("li",{parentName:"ul"},"Create a basic Gazebo world file."),(0,o.yg)("li",{parentName:"ul"},"Integrate your URDF robot model into a Gazebo simulation."),(0,o.yg)("li",{parentName:"ul"},"Differentiate between URDF and SDF and understand their complementary roles in robot description.")),(0,o.yg)("h2",{id:"introduction-to-gazebo-ignition"},"Introduction to Gazebo (Ignition)"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Gazebo")," is a powerful 3D robot simulator that is widely used in the robotics community. It allows you to accurately and efficiently simulate populations of robots in complex indoor and outdoor environments. Gazebo provides robust physics, graphics, and a convenient programming interface."),(0,o.yg)("p",null,"The current generation of Gazebo, often referred to as ",(0,o.yg)("strong",{parentName:"p"},"Gazebo (Ignition)"),", has a modular architecture and improved integration with ROS 2. It's an essential tool for developing and testing robotic algorithms without requiring physical hardware, offering a safe and repeatable environment for experimentation."),(0,o.yg)("h2",{id:"1-installing-gazebo-ignition"},"1. Installing Gazebo (Ignition)"),(0,o.yg)("p",null,"Gazebo (Ignition) is developed as a set of independent libraries (Ignition Math, Ignition Physics, Ignition Rendering, etc.) and integrated into ROS 2. For Humble Hawksbill on Ubuntu 22.04, the default Gazebo version is usually ",(0,o.yg)("strong",{parentName:"p"},"Garden")," or ",(0,o.yg)("strong",{parentName:"p"},"Harmonic"),". We will install the full desktop version."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"# Add the OSRF repository\nsudo sh -c 'echo \"deb http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" > /etc/apt/sources.list.d/ros2-latest.list'\nsudo apt update\nsudo apt install gazebo-garden gazebo-garden-plugins -y\n")),(0,o.yg)("p",null,"After installation, verify that Gazebo can launch:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"gazebo\n")),(0,o.yg)("p",null,"You should see an empty Gazebo GUI window appear."),(0,o.yg)("h2",{id:"2-creating-a-basic-gazebo-world"},"2. Creating a Basic Gazebo World"),(0,o.yg)("p",null,"A Gazebo ",(0,o.yg)("strong",{parentName:"p"},"world")," describes the environment in which your robot will operate. It defines static objects (like walls, floors), dynamic objects, lights, and sensors. Gazebo worlds are defined using ",(0,o.yg)("strong",{parentName:"p"},"Simulation Description Format (SDF)")," files."),(0,o.yg)("p",null,"Let's create a simple world with a flat ground plane and a light source."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Create a ",(0,o.yg)("inlineCode",{parentName:"strong"},"worlds")," directory in your ",(0,o.yg)("inlineCode",{parentName:"strong"},"humanoid_description")," package:")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"cd ~/colcon_ws/src/humanoid_description\nmkdir -p worlds\ncd worlds\n"))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Create ",(0,o.yg)("inlineCode",{parentName:"strong"},"empty_humanoid_world.world"),":")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" ?>\n<sdf version="1.8">\n  <world name="empty_humanoid_world">\n    <physics name="1ms" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n    <light name="sun" type="directional">\n      <cast_shadows>1</cast_shadows>\n      <pose>0 0 10 0 -30 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.5 0.1 -0.9</direction>\n      <spot>\n        <inner_angle>0</inner_angle>\n        <outer_angle>0</outer_angle>\n        <falloff>0</falloff>\n      </spot>\n    </light>\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>100</mu>\n                <mu2>50</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n            <specular>0.8 0.8 0.8 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n')),(0,o.yg)("p",{parentName:"li"},(0,o.yg)("em",{parentName:"p"},"File: ",(0,o.yg)("inlineCode",{parentName:"em"},"empty_humanoid_world.world")))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Launch Gazebo with the custom world:")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"# Ensure you are in your colcon_ws and have sourced setup.bash\ncd ~/colcon_ws\nsource install/setup.bash\n\n# Set GAZEBO_MODEL_PATH so Gazebo can find models if you add them later\nexport GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:$(ros2 pkg prefix humanoid_description)/share/humanoid_description/models\n\ngazebo --verbose -r src/humanoid_description/worlds/empty_humanoid_world.world\n")),(0,o.yg)("p",{parentName:"li"},"You should see Gazebo launch with a grey ground plane."))),(0,o.yg)("h2",{id:"3-integrating-urdf-models-into-gazebo"},"3. Integrating URDF Models into Gazebo"),(0,o.yg)("p",null,"While URDF is excellent for describing a robot's kinematic and dynamic properties, ",(0,o.yg)("strong",{parentName:"p"},"SDF (Simulation Description Format)")," is Gazebo's native format for describing everything in a simulation, including robots, environments, and sensors. SDF is more expressive than URDF, supporting features like nested models, plugins, and more complex sensor definitions."),(0,o.yg)("p",null,"Fortunately, Gazebo can directly parse URDF files and convert them internally to SDF. For full simulation fidelity, however, you might want to augment your URDF with Gazebo-specific extensions or even write a full SDF model."),(0,o.yg)("p",null,"To spawn our ",(0,o.yg)("inlineCode",{parentName:"p"},"humanoid_segment.urdf")," from the previous chapter into this Gazebo world, we'll use a ROS 2 package called ",(0,o.yg)("inlineCode",{parentName:"p"},"ros_ign_gazebo"),"."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Install ",(0,o.yg)("inlineCode",{parentName:"strong"},"ros_ign_gazebo"),":")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"sudo apt install ros-humble-ros-ign-gazebo -y\n"))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Create a launch file to spawn the robot:"),"\nCreate a ",(0,o.yg)("inlineCode",{parentName:"p"},"launch")," directory in ",(0,o.yg)("inlineCode",{parentName:"p"},"humanoid_description")," and a file ",(0,o.yg)("inlineCode",{parentName:"p"},"spawn_humanoid_segment.launch.py"),":"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"cd ~/colcon_ws/src/humanoid_description\nmkdir -p launch\ncd launch\n")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-python"},"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    pkg_humanoid_description = get_package_share_directory('humanoid_description')\n    urdf_file = os.path.join(pkg_humanoid_description, 'urdf', 'humanoid_segment.urdf')\n    world_file = os.path.join(pkg_humanoid_description, 'worlds', 'empty_humanoid_world.world')\n\n    # Launch Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(get_package_share_directory('ros_ign_gazebo'), 'launch', 'ign_gazebo.launch.py')\n        ),\n        launch_arguments={'ign_args': '-r ' + world_file}.items()\n    )\n\n    # Spawn robot\n    spawn_entity = Node(\n        package='ros_ign_gazebo',\n        executable='create',\n        output='screen',\n        arguments=['-string', open(urdf_file).read(),\n                   '-name', 'humanoid_segment',\n                   '-x', '0',\n                   '-y', '0',\n                   '-z', '0.5']\n    )\n\n    # Publish robot states\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': open(urdf_file).read()}]\n    )\n\n    # Joint State Publisher GUI for manual joint control in RViz2\n    joint_state_publisher_gui = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui',\n        name='joint_state_publisher_gui',\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        spawn_entity,\n        robot_state_publisher,\n        joint_state_publisher_gui\n    ])\n")),(0,o.yg)("p",{parentName:"li"},(0,o.yg)("em",{parentName:"p"},"File: ",(0,o.yg)("inlineCode",{parentName:"em"},"spawn_humanoid_segment.launch.py")))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Update ",(0,o.yg)("inlineCode",{parentName:"strong"},"setup.py")," to install launch and world files:"),"\nOpen ",(0,o.yg)("inlineCode",{parentName:"p"},"~/colcon_ws/src/humanoid_description/setup.py")," and add the following inside the ",(0,o.yg)("inlineCode",{parentName:"p"},"data_files")," list:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-python"},"import os\nfrom glob import glob\n# ...\ndata_files=[\n    ('share/ament_index/resource_index/packages', ['resource/' + package_name]),\n    ('share/' + package_name, ['package.xml']),\n    (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][y]'))), # Add this line for launch files\n    (os.path.join('share', package_name, 'urdf'), glob(os.path.join('urdf', '*urdf*'))), # Add this line for URDF/Xacro files\n    (os.path.join('share', package_name, 'worlds'), glob(os.path.join('worlds', '*world*'))), # Add this line for world files\n],\n# ...\n"))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Rebuild the package:")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"cd ~/colcon_ws\ncolcon build --packages-select humanoid_description\nsource install/setup.bash\n"))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Launch the simulation:")),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"ros2 launch humanoid_description spawn_humanoid_segment.launch.py\n")),(0,o.yg)("p",{parentName:"li"},"You should now see Gazebo launch with your ",(0,o.yg)("inlineCode",{parentName:"p"},"humanoid_segment")," model in the world. You can manipulate its joints using the ",(0,o.yg)("inlineCode",{parentName:"p"},"joint_state_publisher_gui"),"."))),(0,o.yg)("h2",{id:"urdf-vs-sdf-complementary-roles"},"URDF vs. SDF: Complementary Roles"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"URDF (Unified Robot Description Format)"),":"),(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Purpose"),": Primarily for kinematic and dynamic description of a single robot. It defines the robot's structure, joints, and some physical properties."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Strengths"),": Simplicity, widely adopted in ROS, good for basic robot visualization and control."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Limitations"),": Cannot describe environments, complex sensors, or nested models effectively."))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"SDF (Simulation Description Format)"),":"),(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Purpose"),": A comprehensive XML format for describing environments, robots, and other objects in a simulator (like Gazebo). It's designed to be more expressive than URDF."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Strengths"),": Supports nested models, advanced physics properties, detailed sensor definitions, environmental elements."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Limitations"),": Can be more complex to write manually, primarily used within Gazebo.")))),(0,o.yg)("p",null,"In practice, many workflows involve starting with a URDF for the robot and then either:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Using a ",(0,o.yg)("inlineCode",{parentName:"li"},"ros_ign_gazebo")," to directly spawn the URDF into Gazebo (as we did above)."),(0,o.yg)("li",{parentName:"ol"},"Creating an SDF file that imports the URDF and adds Gazebo-specific plugins, sensors, and environmental details. This hybrid approach leverages the simplicity of URDF for robot structure and the power of SDF for full simulation fidelity.")),(0,o.yg)("h2",{id:"conclusion"},"Conclusion"),(0,o.yg)("p",null,"You have successfully set up the Gazebo (Ignition) simulation environment, created a custom world, and integrated your URDF robot model. You also understand the distinct but complementary roles of URDF and SDF in describing robotic systems for simulation. This foundation is crucial for developing and testing complex robotic behaviors in a virtual environment."),(0,o.yg)("hr",null),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Next Steps"),": Building on this simulation setup, the next chapter will explore advanced physics modeling and collision detection to ensure realistic robot interactions within Gazebo."))}g.isMDXComponent=!0},5680:(e,n,a)=>{a.d(n,{xA:()=>u,yg:()=>m});var t=a(6540);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){o(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function l(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef(function(e,n){var a=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(a),c=o,m=d["".concat(s,".").concat(c)]||d[c]||g[c]||i;return a?t.createElement(m,r(r({ref:n},u),{},{components:a})):t.createElement(m,r({ref:n},u))});function m(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=a[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"}}]);